---
title : 3.Sorting
date: 2020-03-06
categories: algorithm
tags:
    - sorting algorithm
    - bubble sort
    - insert sort
    - select sort
    - merge sort
    - quick sort
use_math: true
toc: true
---

앞에서 이상한 복잡도니 컴퓨터니 뭐니 해놓고 갑자기 뜬금없이 Sorting은 무었인가? 싶은 사람이 많을 것이다…(가 아니라, 그렇기를 바란다).

먼저 정렬이 재미있는 우리는 정렬에 걸리는 최소 시간 복잡도를 안다는 것이다. 
즉, 가장 효율적인 알고리즘이 존재한다. 
이후에 서술하겠지만, 비교기반 정렬의 시간 복잡도는 $O(n\log{n})$으로 더 줄일 수 없다.

(이는 결정 트리와 스털링 근사라는 멋진(기괴한)방법을 쓰면 되는데 나중에 부록으로 첨부할 예정임..)

## Sorting 1
재윤이는 2장에서 배운 이진탐색은 기본적으로 정렬이 되어있어야 한다는 것을 깨달았다.

재윤이를 도와 정렬하는 방법을 찾아보자

### Problems

#### 1

길이가 n인 정수형 1차원 배열에 값들이 저장되어 있다.

이 배열을 오름차순으로 정렬하는 코드를 작성하라.



#### 2-1

인접한 두 원소간의 값을 바꾸는 함수가 있다.

```c++

```

이 함수를 이용해서 값을 정렬하는 방법을 생각해보자.

#### 2-2

```c++

```

위 코드에서의 시간복잡도, 공간복잡도를 구하라.

이 방법을 `bubble sort`라고 한다.

> **Note:** bubble sort라고 하는 이유는 생각보다 단순한데, 거품이 올라가는 것 처럼 큰 수가 뒤로 가기 때문이다.

---

#### 3-1

재윤이는 `2-2`가 느려지는 이유가 교체를 너무 많이 해서라고 생각한다.

재윤이는 주어진 구간의 최소값을 가지는 원소를 구하는 함수와, 임의의 두 원소를 교체하는 함수를 만들었다.

```c++

```

다음 함수를 이용해서 거품정렬을 더 최적화 시켜보자

####  3-2

다음은 재윤이가 작성한 코드이다

```c++

```
시간복잡도와 공간복잡도를 구하라.

이것을 `selection sort`라고 한다.

---

## Sorting 2
똑똑한 영민이는 재윤이가 한심하게 정렬을 하는 것을 보고 재밌는 정렬 방법을 소개하려고 한다.

### problems

#### 4-1

정렬된 두 배열이 주어져 있을 때, 두 배열의 원소를 모두 가지는 정렬된 배열을 만드는 방법을 생각해보자.

#### 4-2

다음은 영민이가 작성한 코드이다.

```c++

```

시간 복잡도와 공간복잡도를 구하라

영민이는 **자비롭기 때문에** 재윤이가 깨달을 기회를 주려고 한다. 다음 문제를 생각해보자

#### 4-3

[분할정복]...

다음과 같은 방법을 분할 정복이라고 한다.
> 다음에 추가로 다룰 것이다.

#### 4-4

주어진 배열이 있을때, `4-2`의 코드를 이용해서 정렬을 하는 방법을 생각해보자.

#### 4-5

다음은 재윤이가 영민이의 `가르침`을 통해 작성한 코드이다.

```c++

```

시간복잡도를 생각해보자

이 방법을 `Merge sort`라고 한다.

---

#### 5-1

재윤이는 다음과 같은 궁금증이 들었다.

> `4`번문제에서 쓴 방법에서 나누는 방법을 값을 기준으로 하면 안될까?

값을 기준으로 정렬하는 방법을 생각해보자

> **Note:**  `4`번문제에서는 index를 기준으로 정렬하였다

#### 5-2

```c++

```

다음은 재윤이가 작성한 코드이다

이 방법을 `quick sort`라고 한다.

####  5-3 (bouns)
분할 상환 분석을 이용해서 `quick sort`의 시간복잡도를 구하여라

---

## 마무리 하면서

여기서는 비교기반 정렬에 대해서 다루었지만, 다양한 방법의 정렬이 존재한다.

추후에 기회가 된다면 부록에 비교기반 정렬의 하한분석에 대해서 다룰려고 한다.

트리에 관한 자료후에 heap sort에 관한 내용을 추가할 예정이다.

